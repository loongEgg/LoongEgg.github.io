{"meta":{"title":"Loong Egg","subtitle":"","description":"一个强大的蓝人","author":"Loong Egg","url":"https://LoongEgg.github.io","root":"/"},"pages":[{"title":"All Categories","date":"2020-06-13T04:28:29.000Z","updated":"2020-06-13T04:30:49.410Z","comments":true,"path":"categories/index.html","permalink":"https://loongegg.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-06-13T04:44:20.000Z","updated":"2020-06-13T05:00:10.349Z","comments":true,"path":"about/index.html","permalink":"https://loongegg.github.io/about/index.html","excerpt":"","text":"一个强大的蓝人地精工程学毕业，开源软件开发与布道者 专精 程序开发 WPF/C#、MVVM设计模式 UI、Font设计 Inkscape、Fontforge 三维建模 FreeCAD 视频剪辑 Blender、Olive PCB软硬件设计 KiCAD、CubeIDE 以上专业名词的拼写 联系我 Email loongegg@163.com 知乎主页 https://www.zhihu.com/people/inner-geek bilibi主页 https://space.bilibili.com/14343016 微信公众号 香辣恐龙蛋"},{"title":"All Tags","date":"2020-06-13T04:23:21.000Z","updated":"2020-06-13T04:26:11.891Z","comments":true,"path":"tags/index.html","permalink":"https://loongegg.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C#/Udp-4.WPF发送端","slug":"C-Udp-4-WPF发送端","date":"2020-06-13T06:13:17.000Z","updated":"2020-06-13T06:36:48.495Z","comments":true,"path":"2020/06/13/C-Udp-4-WPF发送端/","link":"","permalink":"https://loongegg.github.io/2020/06/13/C-Udp-4-WPF%E5%8F%91%E9%80%81%E7%AB%AF/","excerpt":"","text":"摘要 创建WPF/C#的UdpSender客户端，并使用MVVM模式完成Name和Unit的绑定 前言1. 系列主题本系列文章，旨在实现使用Json进行配置的Udp收发器 An Udp Sender &amp; Receiver using json file to configure 2. 本文主题class类到json的序列化与反序列化 3. 目标框架(target framework) .net framework 4.5 to support using in windows with .net framework &gt;= 4.5 .net standard 2.0 to support using in linux with .net core &gt;= 2.0 4. 项目依赖（Dependency） LoongEgg.DependencyInjection IoC container , you can get it from nuget or my github LoongEgg.MvvmCore an OpenSource cross-platform &amp; cross-framework Mvvm lib , you can get it from nuget or my github LoongEgg.LoongLog an OpenSource cross-platform &amp; cross-framework log tool, you can get it from nuget or my github Newtonsoft.Json 5. 项目地址(Source code) github 6. 发行版获取 Search in nuget: LoongEgg.UdpCore","categories":[{"name":"C#/UDP","slug":"C-UDP","permalink":"https://loongegg.github.io/categories/C-UDP/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://loongegg.github.io/tags/C/"},{"name":"UDP","slug":"UDP","permalink":"https://loongegg.github.io/tags/UDP/"},{"name":"json","slug":"json","permalink":"https://loongegg.github.io/tags/json/"},{"name":"WPF","slug":"WPF","permalink":"https://loongegg.github.io/tags/WPF/"}]},{"title":"C#/Udp-3.class类到json的序列化与反序列化","slug":"C-Udp-3-class类到json的序列化与反序列化","date":"2020-06-13T05:46:21.000Z","updated":"2020-06-13T06:26:15.387Z","comments":true,"path":"2020/06/13/C-Udp-3-class类到json的序列化与反序列化/","link":"","permalink":"https://loongegg.github.io/2020/06/13/C-Udp-3-class%E7%B1%BB%E5%88%B0json%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"摘要class类到json的序列化与反序列化 前言1. 系列主题本系列文章，旨在实现使用Json进行配置的Udp收发器 An Udp Sender &amp; Receiver using json file to configure 2. 目标框架(target framework) .net framework 4.5 to support using in windows with .net framework &gt;= 4.5 .net standard 2.0 to support using in linux with .net core &gt;= 2.0 3. 项目依赖（Dependency） LoongEgg.LoongLog an OpenSource cross-platform &amp; cross-framework log tool, you can get it from nuget or my github Newtonsoft.Json 4. 项目地址(Source code) github 5. 发行版获取 Search in nuget: LoongEgg.UdpCore 基本json文件1234567891011121314151617181920212223242526&#123; \"PackName\": \"AltitudePack\", \"PackID\": 233, \"Items\": [ &#123; \"Name\": \"GPS_Alt\", \"Unit\": \"m\", \"Length\": 2, \"BigEndian\": false, \"Resolution\": 1.0, \"Signed\": true, \"Maximum\": 100, \"Minimum\": -100 &#125;, &#123; \"Name\": \"BRAVO_Alt\", \"Unit\": \"m\", \"Length\": 2, \"BigEndian\": false, \"Resolution\": 0.5, \"Signed\": false, \"Maximum\": 100, \"Minimum\": -100 &#125; ]&#125; 单个数据项定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* | 个人微信：InnerGeeker | 联系邮箱：LoongEgg@163.com | 创建时间：2020/6/12 20:24:28 | 主要用途：数据包中单个数据项的定义 | 更改记录： | 时间 版本 更改 */namespace LoongEgg.UdpCore&#123; /// &lt;summary&gt; /// 单个数据项定义 /// &lt;/summary&gt; public class ItemConfig &#123; /// &lt;summary&gt; /// 数据名称 /// &lt;/summary&gt; public string Name &#123; get; set; &#125; /// &lt;summary&gt; /// 单位 /// &lt;/summary&gt; public string Unit &#123; get; set; &#125; /// &lt;summary&gt; /// 字节长度 /// &lt;/summary&gt; public int Length &#123; get; set; &#125; /// &lt;summary&gt; /// 大端在前？ /// &lt;/summary&gt; public bool BigEndian &#123; get; set; &#125; /// &lt;summary&gt; /// 数据精度，精度乘以传进来的数据=实际的数值 /// &lt;/summary&gt; public float Resolution &#123; get; set; &#125; /// &lt;summary&gt; /// 有无符号？ /// &lt;/summary&gt; public bool Signed &#123; get; set; &#125; /// &lt;summary&gt; /// 数据的最大值 /// &lt;/summary&gt; public float Maximum &#123; get; set; &#125; /// &lt;summary&gt; /// 数据的最小值 /// &lt;/summary&gt; public float Minimum &#123; get; set; &#125; /// &lt;summary&gt; /// 打印数据定义信息到字符串 /// &lt;/summary&gt; /// &lt;returns&gt;格式化后的定义信息&lt;/returns&gt; public override string ToString() &#123; return $\"Name=&#123;Name&#125;, Unit=&#123;Unit&#125;, Resolution=&#123;Resolution&#125;, Signed=\" + (Signed ? \"true\" : \"false\") + $\", Maximum=&#123;Maximum&#125;, Minimum=&#123;Minimum&#125;\"; &#125; &#125;&#125; 单个json文件对应的class定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596using Newtonsoft.Json;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;/* | 个人微信：InnerGeeker | 联系邮箱：LoongEgg@163.com | 创建时间：2020/6/12 20:41:39 | 主要用途：从json文件读取数据包协议 | 更改记录： | 时间 版本 更改 */namespace LoongEgg.UdpCore&#123; /// &lt;summary&gt; /// 数据包，可以直接从json文件反序列化 /// &lt;/summary&gt; public class JsonPackConfig &#123; /// &lt;summary&gt; /// 当前包的名字 /// &lt;/summary&gt; public string PackName &#123; get; set; &#125; = \"[Undefined]\"; /// &lt;summary&gt; /// 当前包的ID号, 注意为单字节无符号数 /// &lt;/summary&gt; public byte PackID &#123; get; set; &#125; /// &lt;summary&gt; /// 包的字节总长度, 注意最大长度为255 /// &lt;/summary&gt; public byte Length &#123; get &#123; int count = 0; if (Items.Any()) &#123; Items.ForEach(i =&gt; count += i.Length); return (byte)count; &#125; return 0; &#125; &#125; /// &lt;summary&gt; /// 数据对象定义的集合 /// &lt;/summary&gt; public List&lt;ItemConfig&gt; Items &#123; get; set; &#125; /// &lt;summary&gt; /// 从指定的文件反序列化数据包的定义 /// &lt;/summary&gt; /// &lt;param name=\"path\"&gt;文件路径&lt;/param&gt; /// &lt;returns&gt;反序列化后的数据包&lt;/returns&gt; public static JsonPackConfig DeserializeFromFile(string path) &#123; using (StreamReader reader = File.OpenText(path)) &#123; JsonSerializer serializer = JsonSerializer.Create(); var pack = serializer.Deserialize(reader, typeof(JsonPackConfig)) as JsonPackConfig; return pack; &#125; &#125; /// &lt;summary&gt; /// 将协议转换为json字符串形式 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string SerializeToJsonString() =&gt; JsonConvert.SerializeObject(this, Formatting.Indented); /// &lt;summary&gt; /// 将所有的数据协议项转换为一个字符串 /// &lt;/summary&gt; public override string ToString() &#123; StringBuilder builder = new StringBuilder(); builder.AppendLine($\"PackName=&#123;PackName&#125;, PackID=&#123;PackID&#125;:\"); if (Items.Any()) &#123; Items.ForEach( i =&gt; &#123; builder.AppendLine(i.ToString()); &#125;); return builder.ToString(); &#125; return \"JsonPackDefinition is undefined\"; &#125; &#125;&#125; 运用实例123456789101112131415161718192021222324252627using System;using System.Diagnostics;namespace LoongEgg.UdpCore.JsonDemo&#123; class Program &#123; static void Main(string[] args) &#123; try &#123; JsonPackConfig pack = JsonPackConfig.DeserializeFromFile(\"AltPack.json\"); Console.WriteLine(\"Desializing...\"); Console.WriteLine(pack.ToString()); Console.WriteLine(\"Serializing...\"); Console.WriteLine(pack.SerializeToJsonString()); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; Debugger.Break(); &#125; &#125;&#125;","categories":[{"name":"C#/UDP","slug":"C-UDP","permalink":"https://loongegg.github.io/categories/C-UDP/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://loongegg.github.io/tags/C/"},{"name":"UDP","slug":"UDP","permalink":"https://loongegg.github.io/tags/UDP/"},{"name":"json","slug":"json","permalink":"https://loongegg.github.io/tags/json/"}]},{"title":"C#/Udp-2.收发通信客户端的创建","slug":"C-Udp-2-收发通信客户端的创建","date":"2020-06-13T05:36:23.000Z","updated":"2020-06-13T06:26:16.819Z","comments":true,"path":"2020/06/13/C-Udp-2-收发通信客户端的创建/","link":"","permalink":"https://loongegg.github.io/2020/06/13/C-Udp-2-%E6%94%B6%E5%8F%91%E9%80%9A%E4%BF%A1%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"","text":"摘要基本UDP收发通信客户端的创建 前言1. 系列主题本系列文章，旨在实现使用Json进行配置的Udp收发器 An Udp Sender &amp; Receiver using json file to configure 2. 目标框架(target framework) .net framework 4.5 to support using in windows with .net framework &gt;= 4.5 .net standard 2.0 to support using in linux with .net core &gt;= 2.0 3. 项目依赖（Dependency） LoongEgg.LoongLog an OpenSource cross-platform &amp; cross-framework log tool, you can get it from nuget or my github Newtonsoft.Json 4. 项目地址(Source code) github 5. 发行版获取 Search in nuget: LoongEgg.UdpCore 发送端Program.cs1234567891011121314151617181920212223using LoongEgg.LoongLog;using System;namespace UdpSender.Net45&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(\"Hello World!\"); Logger.Enable(Loggers.ConsoleLogger | Loggers.DebugLogger); var sender = new LoongEgg.UdpCore.UdpSender(2233, true); bool stop = false; do &#123; Console.WriteLine(\"Enter a message or stop/s to exit\"); string input = Console.ReadLine(); stop = input.ToLower() == \"stop\" | input.ToLower() == \"s\"; sender.SendAsync($\"&#123;input&#125;\"); &#125; while (!stop); &#125; &#125;&#125; 接收端12345678910111213141516171819using LoongEgg.LoongLog;using System;namespace UdpReceiver.Net45&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(\"Hello World!\"); Logger.Enable(Loggers.ConsoleLogger | Loggers.DebugLogger); var receiver = new LoongEgg.UdpCore.UdpReceiver(2233); receiver.ReaderAsync().Wait(); Console.WriteLine(\"Good bye~\"); &#125; &#125;&#125;","categories":[{"name":"C#/UDP","slug":"C-UDP","permalink":"https://loongegg.github.io/categories/C-UDP/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://loongegg.github.io/tags/C/"},{"name":"UDP","slug":"UDP","permalink":"https://loongegg.github.io/tags/UDP/"}]},{"title":"C#/Udp-1.收发通信基础库的实现","slug":"C-Udp-1-收发通信基础库的实现","date":"2020-06-13T02:29:08.000Z","updated":"2020-06-13T06:26:17.849Z","comments":true,"path":"2020/06/13/C-Udp-1-收发通信基础库的实现/","link":"","permalink":"https://loongegg.github.io/2020/06/13/C-Udp-1-%E6%94%B6%E5%8F%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"摘要基本UDP收发通信基础库的实现 前言1. 系列主题本系列文章，旨在实现使用Json进行配置的Udp收发器 An Udp Sender &amp; Receiver using json file to configure 2. 目标框架(target framework) .net framework 4.5 to support using in windows with .net framework &gt;= 4.5 .net standard 2.0 to support using in linux with .net core &gt;= 2.0 3. 项目依赖（Dependency） LoongEgg.LoongLog an OpenSource cross-platform &amp; cross-framework log tool, you can get it from nuget or my github Newtonsoft.Json 4. 项目地址(Source code) github 5. 发行版获取 Search in nuget: LoongEgg.UdpCore UdpSender.cs1.Properties123456789/// &lt;summary&gt;/// IP端口/// &lt;/summary&gt;public IPEndPoint EndPoint &#123; get; private set; &#125;/// &lt;summary&gt;/// 组地址/// &lt;/summary&gt;public string GroupAddress &#123; get; private set; &#125; 2.Constructors12345678910111213141516171819202122232425/// &lt;summary&gt;/// Udp发送器的构造器/// &lt;/summary&gt;/// &lt;param name=\"port\"&gt;端口号&lt;/param&gt;/// &lt;param name=\"isBroadcast\"&gt;组播?&lt;/param&gt; /// &lt;param name=\"groupAddress\"&gt;组地址&lt;/param&gt;/// &lt;param name=\"isIpV6\"&gt;IpV6模式?&lt;/param&gt;public UdpSender( int port, bool isBroadcast, string groupAddress = null, bool isIpV6 = false)&#123; GroupAddress = groupAddress; string hostName = Dns.GetHostName(); EndPoint = GetIPEndPoint(port, isBroadcast, hostName, groupAddress, isIpV6).Result; GroupAddress = groupAddress; string hostName = Dns.GetHostName(); EndPoint = GetIPEndPoint(port, isBroadcast, hostName, groupAddress, isIpV6).Result; Debug.WriteLine( $\"IPEndPoint: \" + $\"&#123;nameof(port)&#125;=&#123;port&#125;, i&#123;nameof(isBroadcast)&#125;=&#123;isBroadcast&#125;, \" + $\"&#123;nameof(hostName)&#125;=&#123;hostName&#125;, &#123;nameof(groupAddress)&#125;=&#123;groupAddress&#125;, \" + $\"&#123;nameof(isIpV6)&#125;=&#123;isIpV6&#125;\");&#125; 3.Public Methods12345678910111213141516171819202122232425262728293031/// &lt;summary&gt;/// 发送信息/// &lt;/summary&gt;/// &lt;param name=\"message\"&gt;待发送的信息&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async void SendAsync(string message)&#123; try &#123; string localhost = Dns.GetHostName(); using (var client = new UdpClient()) &#123; if (GroupAddress != null) &#123; client.JoinMulticastGroup(IPAddress.Parse(GroupAddress)); &#125; byte[] datagram = Encoding.UTF8.GetBytes(message); await client.SendAsync(datagram, datagram.Length, EndPoint); if (GroupAddress != null) &#123; client.DropMulticastGroup(IPAddress.Parse(GroupAddress)); &#125; &#125; &#125; catch (Exception ex) &#123; throw ex; &#125;&#125; 4. Private Methods123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/// &lt;summary&gt;/// 获取指定的IP端口/// &lt;/summary&gt;/// &lt;param name=\"port\"&gt;端口号&lt;/param&gt;/// &lt;param name=\"isBroadcast\"&gt;组播?&lt;/param&gt;/// &lt;param name=\"hostName\"&gt;主机名称&lt;/param&gt;/// &lt;param name=\"groupAddress\"&gt;组地址&lt;/param&gt;/// &lt;param name=\"isIpV6\"&gt;IpV6模式?&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static async Task&lt;IPEndPoint&gt; GetIPEndPoint( int port, bool isBroadcast, string hostName, string groupAddress, bool isIpV6)&#123; IPEndPoint endpoint; try &#123; if (isBroadcast) &#123; endpoint = new IPEndPoint(IPAddress.Broadcast, port); Logger.Debug($\"&#123;nameof(isBroadcast)&#125;=&#123;isBroadcast&#125;, &#123;nameof(port)&#125;=&#123;port&#125; \"); &#125; else if (hostName != null) &#123; IPHostEntry hostEntry = await Dns.GetHostEntryAsync(hostName); IPAddress address; if (isIpV6) &#123; address = hostEntry.AddressList.Where( a =&gt; a.AddressFamily == AddressFamily.InterNetworkV6 ).FirstOrDefault(); &#125; else &#123; address = hostEntry.AddressList.Where( a =&gt; a.AddressFamily == AddressFamily.InterNetwork ).FirstOrDefault(); &#125; endpoint = new IPEndPoint(address, port); Logger.Debug($\"&#123;nameof(hostName)&#125;=&#123;hostName&#125;, &#123;nameof(address)&#125;=&#123;address&#125;, &#123;nameof(isIpV6)&#125;=&#123;isIpV6&#125;\"); &#125; else if (groupAddress != null) &#123; endpoint = new IPEndPoint(IPAddress.Parse(groupAddress), port); Logger.Debug($\"&#123;nameof(groupAddress)&#125;=&#123;groupAddress&#125;, &#123;nameof(port)&#125;=&#123;port&#125; \"); &#125; else &#123; throw new InvalidOperationException($\"&#123;nameof(hostName)&#125;, &#123;nameof(isBroadcast)&#125;, or &#123;nameof(groupAddress)&#125; must be set\"); &#125; &#125; catch (Exception ex) &#123; throw ex; &#125; return endpoint;&#125; UdpReceiver.cs1.Properties123456789/// &lt;summary&gt;/// 端口号/// &lt;/summary&gt;public int Port &#123; get; private set; &#125;/// &lt;summary&gt;/// 组地址/// &lt;/summary&gt;public string GroupAddress &#123; get; private set; &#125; 2.Constructors1234567891011/// &lt;summary&gt;/// 创建一个新的接收器/// &lt;/summary&gt;/// &lt;param name=\"port\"&gt;端口号&lt;/param&gt;/// &lt;param name=\"groupAddress\"&gt;组地址&lt;/param&gt;public UdpReceiver(int port, string groupAddress = null)&#123; GroupAddress = groupAddress; Port = port; Logger.Info($\"Listening to &#123;nameof(Port)&#125;=&#123;Port&#125;, &#123;nameof(GroupAddress)&#125;=&#123;GroupAddress&#125;\");&#125; 3.Public Methods1234567891011121314151617181920212223242526272829303132/// &lt;summary&gt;/// 接收器工作/// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt;public async Task ReaderAsync()&#123; using (var client = new UdpClient(Port)) &#123; if (GroupAddress != null) &#123; Logger.Debug($\"JoinMulticastGroup = &#123;GroupAddress&#125;\"); client.JoinMulticastGroup(IPAddress.Parse(GroupAddress)); &#125; bool completed = false; do &#123; Logger.Debug(\"Listening...\"); UdpReceiveResult result = await client.ReceiveAsync(); byte[] datagram = result.Buffer; ; string received = Encoding.UTF8.GetString(datagram); Logger.Info($\"Received (from &#123;result.RemoteEndPoint.Address.ToString()&#125;)-&gt; &#123;received&#125;\"); completed = (received == \"closed\"); &#125; while (!completed); Logger.Debug(\"Receiver closing\"); if (GroupAddress != null) &#123; client.DropMulticastGroup(IPAddress.Parse(GroupAddress)); &#125; &#125;&#125;","categories":[{"name":"C#/UDP","slug":"C-UDP","permalink":"https://loongegg.github.io/categories/C-UDP/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://loongegg.github.io/tags/C/"},{"name":"UDP","slug":"UDP","permalink":"https://loongegg.github.io/tags/UDP/"}]}],"categories":[{"name":"C#/UDP","slug":"C-UDP","permalink":"https://loongegg.github.io/categories/C-UDP/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://loongegg.github.io/tags/C/"},{"name":"UDP","slug":"UDP","permalink":"https://loongegg.github.io/tags/UDP/"},{"name":"json","slug":"json","permalink":"https://loongegg.github.io/tags/json/"},{"name":"WPF","slug":"WPF","permalink":"https://loongegg.github.io/tags/WPF/"}]}