{"meta":{"title":"Loong Egg","subtitle":"","description":"一个强大的蓝人","author":"Loong Egg","url":"https://LoongEgg.github.io","root":"/"},"pages":[{"title":"All Categories","date":"2020-06-13T04:28:29.000Z","updated":"2020-06-13T04:30:49.410Z","comments":true,"path":"categories/index.html","permalink":"https://loongegg.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-06-13T04:44:20.000Z","updated":"2020-06-13T10:15:55.781Z","comments":true,"path":"about/index.html","permalink":"https://loongegg.github.io/about/index.html","excerpt":"","text":"一个强大的蓝人地精工程学毕业，开源软件开发与布道者 专精 程序开发 WPF/C#、MVVM设计模式 UI、Font设计 Inkscape、Fontforge 三维建模 FreeCAD 视频剪辑 Blender、Olive PCB软硬件设计 KiCAD、CubeIDE 以上专业名词的拼写 联系我 Email loongegg@163.com 知乎主页 https://www.zhihu.com/people/inner-geek bilibi主页 https://space.bilibili.com/14343016 微信公众号 香辣恐龙蛋 github https://github.com/loongEgg"},{"title":"All Tags","date":"2020-06-13T04:23:21.000Z","updated":"2020-06-13T04:26:11.891Z","comments":true,"path":"tags/index.html","permalink":"https://loongegg.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在Windows中使用VSCode远程开发ubuntu中的.netcore项目","slug":"在Windows中使用VSCode远程开发ubuntu中的-netcore项目","date":"2020-06-14T05:18:08.000Z","updated":"2020-06-16T11:20:34.133Z","comments":true,"path":"2020/06/14/在Windows中使用VSCode远程开发ubuntu中的-netcore项目/","link":"","permalink":"https://loongegg.github.io/2020/06/14/%E5%9C%A8Windows%E4%B8%AD%E4%BD%BF%E7%94%A8VSCode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91ubuntu%E4%B8%AD%E7%9A%84-netcore%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"摘要 特点文件在windows中方便管理，开发环境在linux调试效果真实 注意本文章写于2020年，基于WSL中的ubuntu18.04LTS, 目标为.netcore 3.1 sdk可能缺少一些插件比如C#在VS Code插件中安装，有些插件会自动提示安装，要记得点yes比如VS code的WSL插件 1.dotnetcore sdk 安装 官网信息https://docs.microsoft.com/zh-cn/dotnet/core/install/linux-ubuntu 12wget https://packages.microsoft.com/config/ubuntu/18.04/packages-microsoft-prod.deb -O packages-microsoft-prod.debsudo dpkg -i packages-microsoft-prod.deb 1234sudo apt-get update; \\sudo apt-get install -y apt-transport-https &amp;&amp; \\sudo apt-get update &amp;&amp; \\sudo apt-get install -y dotnet-sdk-3.1 检查安装情况 dotnet -v2.创建.netcore console 在Windows中某一盘下面，比如我在e:\\linux\\netcoretest\\创建了一个文件夹 在linux下移动进去 cd /mnt/e/linux/netcoretest 在linux下创建项目 dotnet new console 在linux下运行项目 dotnet run 会显示： Hello World! 在windows下打开文件夹 更改Hello World!为Hello loongegg.github.io!并保存 在linux下运行项目输出 dotnet run 会显示： Hello loongegg.github.io! ~","categories":[],"tags":[]},{"title":"在Windows中安装Linux子系统和VSCode","slug":"在Windows中安装Linux子系统和VSCode","date":"2020-06-14T04:25:36.000Z","updated":"2020-06-16T11:20:34.138Z","comments":true,"path":"2020/06/14/在Windows中安装Linux子系统和VSCode/","link":"","permalink":"https://loongegg.github.io/2020/06/14/%E5%9C%A8Windows%E4%B8%AD%E5%AE%89%E8%A3%85Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%92%8CVSCode/","excerpt":"","text":"摘要 特点基于WSL安装，不需要虚拟机，不需要双系统 步骤WSL功能启用, Ubuntu系统安装，换源，VS Code安装 1.WSL功能启用开始菜单 &gt; 设置 &gt; 应用 &gt; 程序和功能(右上角) &gt; 启用或关闭Windows功能(左上角) 适用于Linux的Windows子系统 &gt; 重启 2.Ubuntu18.04LTS安装(2020年建议先用这个)搜索（开始菜单旁边那个），输入store &gt; microsoft store &gt; 搜索ubuntu &gt; 安装18.04LTS 3.Ubuntu换源 启动ubuntu直接在开始菜单点图标，第一次打开要创建账号和密码tips: 记得拿小本子记好密码，不要乱输入忘了，短一点就好，不要有特殊符号不要数字开头 linux下密码输入没有占位符提醒 linux command:- `ls` 查看当前目录下有什么鬼东西 - `cd /mnt` goto my computer - `cd d` goto driver D - `cd ..` 返回上一级 - `cd FOLDER_NAME` 移动到指定的文件夹 - `dotnet new console` 在当前目录下创建一个.netcore控制台，项目名称与目录名称相同 - `dotnet run` 运行.netcore程序，当前目录必须要有.netcore项目，并且有PROJECT_NAME.csproject文件 - `clear` 清屏 - `sudo apt-get install XX` 安装XX软件换源文件 移动当前目录 cd /etc/apt/ 备份源文件 sudo cp sources.list sources.list.bak 修改源文件 sudo vim sources.list 按两下g让光标到开头 按d, 然后shift+g删除所有内容 复制以下源1234567891011121314deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse 按i进入插入模式（左下角显示INSERT），右键粘贴 ESC退出插入模式 :wq退出 确认文件已更新 cat sources.list 更新源 sudo apt-get update sudo apt-get upgrade 安装VS Code 输入code没有安装会自动安装 安装好后再输入变成启动","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://loongegg.github.io/tags/linux/"},{"name":"WSL","slug":"WSL","permalink":"https://loongegg.github.io/tags/WSL/"},{"name":"VS Code","slug":"VS-Code","permalink":"https://loongegg.github.io/tags/VS-Code/"}]},{"title":"C#/Udp-6.在linux中运行.netcore版的接收器","slug":"C-Udp-6-在linux中运行-netcore版的接收器","date":"2020-06-14T01:34:23.000Z","updated":"2020-06-14T05:47:13.232Z","comments":true,"path":"2020/06/14/C-Udp-6-在linux中运行-netcore版的接收器/","link":"","permalink":"https://loongegg.github.io/2020/06/14/C-Udp-6-%E5%9C%A8linux%E4%B8%AD%E8%BF%90%E8%A1%8C-netcore%E7%89%88%E7%9A%84%E6%8E%A5%E6%94%B6%E5%99%A8/","excerpt":"","text":"摘要 踩坑，填坑，在VS中创建跨平台的.netcore的UdpReceiver控制台实例，running in linux 注意（Caution, 大写加粗）由于引用的Newtonsoft.Json在VS Code使用Nuget添加引用会造成大坑（这就是我一直抵触SB无脑Nuget的原因, 倡导使用简单的库，而不是牛逼但是复杂，出了天坑都不会填），但是在VisualStudio中使用没有问题（所以怪我不会正确引用？） BUG in VS Code when using nuget to add reference ‘Newtonsoft.Json’ already has a dependency defined for ‘Microsoft.CSharp’ 更糟糕的是，我看了官方的issues，人家说这个不是bug，而且由于这个牛逼的库包含在了.NetCore 3.0 的Microsoft.Sharp中，所以可能只要你在自己的库中依赖过之后，再引用自己的库中都会完蛋。 前言1.系列主题本系列文章，旨在实现使用Json进行配置的Udp收发器 An Udp Sender &amp; Receiver using json file to configure 2.目标框架(target framework) .net framework 4.5 to support using in windows with .net framework &gt;= 4.5 .net standard 2.0 to support using in linux with .net core &gt;= 2.0 3.项目依赖（Dependency） LoongEgg.DependencyInjection IoC container , you can get it from nuget or my github LoongEgg.MvvmCore an OpenSource cross-platform &amp; cross-framework Mvvm lib , you can get it from nuget or my github LoongEgg.LoongLog an OpenSource cross-platform &amp; cross-framework log tool, you can get it from nuget or my github Newtonsoft.Json 4.项目地址(Source code) github 5.发行版获取（Realse） Search in nuget: LoongEgg.UdpCore 解决方案（Solution）1.在VS中创建跨平台应用(Creat a .netcore console in VS) 添加 &gt; 新建项目 &gt; .netcore &gt; console 添加引用, nuget search and install LoongEgg.UdpCore 坑爹提醒(Caution, super buggy) 在linux的.netcore sdk 3.0 DO NOT SUPPORT.netcore 2.0 app, 所以只能使用VS2019创建.netcore3.0的console是不是开发python划时代的2.0-&gt;3.0的那波人跑去开发C#了，各种割裂 在VS2019中引用的包的依赖，无法在Nuget中更新 VS2019创建的项目，在linux中dotnet run后，VS中会出错，只能重生成12345678910111213141516171819using LoongEgg.LoongLog;using System;namespace UdpReceiver.Net45&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(\"Hello World!\"); Logger.Enable(Loggers.ConsoleLogger); var receiver = new LoongEgg.UdpCore.UdpReceiver(2233); receiver.ReaderAsync().Wait(); Console.WriteLine(\"Good bye~\"); &#125; &#125;&#125; 生成项目(build) 2.在linux中运行（running in linux） 使用Windows 10中的WSL安装的Ubuntu18.04LTS为例，很多新东西都是坑，能不作就不要作 WSL Ubuntun command tips: ls 查看当前目录下有什么鬼东西 cd /mnt goto my computer cd d goto driver D cd .. 返回上一级 cd FOLDER_NAME 移动到指定的文件夹 dotnet new console 在当前目录下创建一个.netcore控制台，项目名称与目录名称相同 dotnet run 运行.netcore程序，当前目录必须要有.netcore项目，并且有PROJECT_NAME.csproject文件 clear 清屏Move to YOU_SOLUTION_FOLDER in wsl12345678king@DESKTOP-N1M9MC7:~$ cd /mnt/eking@DESKTOP-N1M9MC7:/mnt/e$ cd linux/UdpReceiver.NetCoreLinux/king@DESKTOP-N1M9MC7:/mnt/e/linux/UdpReceiver.NetCoreLinux$ lsProgram.cs UdpReceiver.NetCoreLinux.csproj bin objking@DESKTOP-N1M9MC7:/mnt/e/linux/UdpReceiver.NetCoreLinux$ dotnet runFXXK M$!06/14/2020 10:40:33 [ Info ] -&gt; E:\\Published\\LoongEgg.UdpCore\\LoongEgg.UdpCore\\UdpReceiver.cs &gt; .ctor() &gt; in line[ 41]: Listening to Port=2233, GroupAddress=06/14/2020 10:40:33 [ Dbug ] -&gt; E:\\Published\\LoongEgg.UdpCore\\LoongEgg.UdpCore\\UdpReceiver.cs &gt; ReaderAsync() &gt; in line[ 61]: Listening... 坑爹提醒（Caution, super buggy)重启VS，重开.sln不然满屏错误（reopen .sln）","categories":[{"name":"C#/UDP","slug":"C-UDP","permalink":"https://loongegg.github.io/categories/C-UDP/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://loongegg.github.io/tags/C/"},{"name":"linux","slug":"linux","permalink":"https://loongegg.github.io/tags/linux/"},{"name":".netcore","slug":"netcore","permalink":"https://loongegg.github.io/tags/netcore/"},{"name":"cross platform","slug":"cross-platform","permalink":"https://loongegg.github.io/tags/cross-platform/"}]},{"title":"C#/Udp-5.ViewModel中发送功能的实现","slug":"C-Udp-5-ViewModel中发送功能的实现","date":"2020-06-13T11:28:15.000Z","updated":"2020-06-13T12:11:50.740Z","comments":true,"path":"2020/06/13/C-Udp-5-ViewModel中发送功能的实现/","link":"","permalink":"https://loongegg.github.io/2020/06/13/C-Udp-5-ViewModel%E4%B8%AD%E5%8F%91%E9%80%81%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"摘要 在ViewModel中利用属性改变事件发起Udp通信前言1.系列主题本系列文章，旨在实现使用Json进行配置的Udp收发器 An Udp Sender &amp; Receiver using json file to configure 2.目标框架(target framework) .net framework 4.5 to support using in windows with .net framework &gt;= 4.5 .net standard 2.0 to support using in linux with .net core &gt;= 2.0 3.项目依赖（Dependency） LoongEgg.DependencyInjection IoC container , you can get it from nuget or my github LoongEgg.MvvmCore an OpenSource cross-platform &amp; cross-framework Mvvm lib , you can get it from nuget or my github LoongEgg.LoongLog an OpenSource cross-platform &amp; cross-framework log tool, you can get it from nuget or my github Newtonsoft.Json 4.项目地址(Source code) github 5.发行版获取 Search in nuget: LoongEgg.UdpCore 在ViewModel中增加属性改变处理事件 AltPackViewModel.cs12345678910111213141516171819202122readonly UdpSender Sender;/// &lt;summary&gt;/// 会启动Udp发送器的实例，默认采用组播模式，只需设置端口号一致即可接收到/// &lt;/summary&gt;/// &lt;param name=\"config\"&gt;json配置实例&lt;/param&gt;/// &lt;param name=\"port\"&gt;端口号&lt;/param&gt;public AltPackViewModel(JsonPackConfig config, int port) : this(config)&#123; Gps.PropertyChanged += OnPropertyChanged; Sender = new UdpSender(port, true);&#125;/// &lt;summary&gt;/// 当属性改变时，调用Udp发送功能/// &lt;/summary&gt; private void OnPropertyChanged(object sender, PropertyChangedEventArgs e)&#123; if (e.PropertyName == nameof(AltViewModel.Readout)) &#123; Sender?.SendAsync($\"Gps=&#123;Gps.Readout&#125;\"); &#125;&#125; 更改程序启动代码 App.xaml.cs1234567891011121314151617181920212223242526272829using LoongEgg.DependencyInjection;using LoongEgg.LoongLog;using LoongEgg.UdpCore;using System;using System.Windows;namespace UdpJsonSender.WPF&#123; /// &lt;summary&gt; /// App.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class App : Application &#123; protected override void OnStartup(StartupEventArgs e) &#123; base.OnStartup(e); IoC = new Container(); Logger.EnableDebugLogger(); var config = JsonPackConfig.DeserializeFromFile(AppDomain.CurrentDomain.BaseDirectory + \"AltPack.json\"); IoC.AddOrUpdate(new AltPackViewModel( config, 2233)); // 端口号与接收器一致 &#125; /// &lt;summary&gt; /// 依赖注入容器 /// &lt;/summary&gt; public Container IoC &#123; get; set; &#125; &#125;&#125; 运行测试（注意，如果使用了LoongEgg.LoongLog可以在输出中跟踪程序运行情况）1.启动WPF程序2.启动前面创建的接收端3.拖动GPS的Slider条检查程序运行情况","categories":[{"name":"C#/UDP","slug":"C-UDP","permalink":"https://loongegg.github.io/categories/C-UDP/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://loongegg.github.io/tags/C/"},{"name":"json","slug":"json","permalink":"https://loongegg.github.io/tags/json/"},{"name":"MVVM","slug":"MVVM","permalink":"https://loongegg.github.io/tags/MVVM/"}]},{"title":"C#/Udp-4.WPF发送端界面设计","slug":"C-Udp-4-WPF发送端界面设计","date":"2020-06-13T06:13:17.000Z","updated":"2020-06-13T11:30:54.514Z","comments":true,"path":"2020/06/13/C-Udp-4-WPF发送端界面设计/","link":"","permalink":"https://loongegg.github.io/2020/06/13/C-Udp-4-WPF%E5%8F%91%E9%80%81%E7%AB%AF%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"摘要 创建WPF/C#的UdpSender客户端，并使用MVVM模式完成Name和Unit的绑定前言1.系列主题本系列文章，旨在实现使用Json进行配置的Udp收发器 An Udp Sender &amp; Receiver using json file to configure 2.目标框架(target framework) .net framework 4.5 to support using in windows with .net framework &gt;= 4.5 .net standard 2.0 to support using in linux with .net core &gt;= 2.0 3.项目依赖（Dependency） LoongEgg.DependencyInjection IoC container , you can get it from nuget or my github LoongEgg.MvvmCore an OpenSource cross-platform &amp; cross-framework Mvvm lib , you can get it from nuget or my github LoongEgg.LoongLog an OpenSource cross-platform &amp; cross-framework log tool, you can get it from nuget or my github Newtonsoft.Json 4.项目地址(Source code) github 5.发行版获取 Search in nuget: LoongEgg.UdpCore ViewModels123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using LoongEgg.MvvmCore;/* | 个人微信：InnerGeeker | 联系邮箱：LoongEgg@163.com | 创建时间：2020/6/13 17:00:07 | 主要用途： | 更改记录： | 时间 版本 更改 */namespace UdpJsonSender.WPF&#123; public class AltViewModel : ViewModel &#123; public string Name &#123; get &#123; return _Name; &#125; set &#123; SetProperty(ref _Name, value); &#125; &#125; private string _Name; public string Unit &#123; get &#123; return _Unit; &#125; set &#123; SetProperty(ref _Unit, value); &#125; &#125; private string _Unit; public double Maximum &#123; get &#123; return _Maximum; &#125; set &#123; SetProperty(ref _Maximum, value); &#125; &#125; private double _Maximum; public double Minimum &#123; get &#123; return _Minimum; &#125; set &#123; SetProperty(ref _Minimum, value); &#125; &#125; private double _Minimum; public double Readout &#123; get &#123; return _Readout; &#125; set &#123; SetProperty(ref _Readout, value); &#125; &#125; private double _Readout; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061using LoongEgg.MvvmCore;using LoongEgg.UdpCore;/* | 个人微信：InnerGeeker | 联系邮箱：LoongEgg@163.com | 创建时间：2020/6/13 17:11:16 | 主要用途： | 更改记录： | 时间 版本 更改 */namespace UdpJsonSender.WPF&#123; public class AltPackViewModel : ViewModel &#123; internal static AltPackViewModel DesignInstance &#123; get; &#125; = new AltPackViewModel( JsonPackConfig.DeserializeFromFile( @\"E:\\Published\\LoongEgg.UdpCore\\UdpJsonSender.WPF\\AltPack.json\")); // 根据你自己实际的文件路径写 public string PackName &#123; get &#123; return _PackName; &#125; set &#123; SetProperty(ref _PackName, value); &#125; &#125; private string _PackName; public byte PackId &#123; get &#123; return _PackId; &#125; set &#123; SetProperty(ref _PackId, value); &#125; &#125; private byte _PackId; public AltViewModel Gps &#123; get; set; &#125; public AltViewModel Baro &#123; get; set; &#125; public AltPackViewModel(JsonPackConfig config) &#123; Gps = new AltViewModel &#123; Name = config.Items[0].Name, Unit = config.Items[0].Unit, Minimum = config.Items[0].Minimum, Maximum = config.Items[0].Maximum &#125;; Baro = new AltViewModel &#123; Name = config.Items[1].Name, Unit = config.Items[1].Unit, Minimum = config.Items[1].Minimum, Maximum = config.Items[1].Maximum &#125;; PackName = config.PackName; PackId = config.PackID; &#125; &#125;&#125; App启动设置1234567891011121314151617181920212223242526using LoongEgg.DependencyInjection;using LoongEgg.UdpCore;using System;using System.Windows;namespace UdpJsonSender.WPF&#123; /// &lt;summary&gt; /// App.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class App : Application &#123; protected override void OnStartup(StartupEventArgs e) &#123; base.OnStartup(e); IoC = new Container(); IoC.AddOrUpdate(new AltPackViewModel( JsonPackConfig.DeserializeFromFile(AppDomain.CurrentDomain.BaseDirectory + \"AltPack.json\"))); &#125; /// &lt;summary&gt; /// 依赖注入容器 /// &lt;/summary&gt; public Container IoC &#123; get; set; &#125; &#125;&#125; 前台绑定注意用来提供语法提示的设计时绑定 d:DataContext=&quot;{x:Static local:AltPackViewModel.DesignInstance}&quot; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;Window x:Class=\"UdpJsonSender.WPF.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:local=\"clr-namespace:UdpJsonSender.WPF\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" Title=\"MainWindow\" Width=\"600\" Height=\"300\" d:DataContext=\"&#123;x:Static local:AltPackViewModel.DesignInstance&#125;\" FontSize=\"26\" Foreground=\"Black\" mc:Ignorable=\"d\"&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition /&gt; &lt;RowDefinition /&gt; &lt;/Grid.RowDefinitions&gt; &lt;StackPanel Grid.Row=\"0\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Orientation=\"Horizontal\"&gt; &lt;TextBlock&gt; &lt;Run&gt;PackName:&lt;/Run&gt; &lt;Run Text=\"&#123;Binding PackName&#125;\" /&gt; &lt;Run&gt;, PackID:&lt;/Run&gt; &lt;Run Text=\"&#123;Binding PackId&#125;\" /&gt; &lt;/TextBlock&gt; &lt;/StackPanel&gt; &lt;ListBox Grid.Row=\"1\"&gt; &lt;ListBoxItem VerticalAlignment=\"Center\"&gt; &lt;StackPanel DataContext=\"&#123;Binding Gps&#125;\" Orientation=\"Horizontal\"&gt; &lt;TextBlock Width=\"250\"&gt; &lt;Run Text=\"&#123;Binding Name&#125;\" /&gt; &lt;Run Text=\"&#123;Binding Readout, StringFormat=&#123;&#125;&#123;0:f1&#125;&#125;\" /&gt; &lt;Run Text=\"&#123;Binding Unit, StringFormat=(&#123;0&#125;)&#125;\" /&gt; &lt;/TextBlock&gt; &lt;Slider Width=\"300\" VerticalAlignment=\"Center\" Maximum=\"&#123;Binding Maximum&#125;\" Minimum=\"&#123;Binding Minimum&#125;\" Orientation=\"Horizontal\" Value=\"&#123;Binding Readout&#125;\" /&gt; &lt;/StackPanel&gt; &lt;/ListBoxItem&gt; &lt;ListBoxItem VerticalAlignment=\"Center\"&gt; &lt;StackPanel DataContext=\"&#123;Binding Baro&#125;\" Orientation=\"Horizontal\"&gt; &lt;TextBlock Width=\"250\"&gt; &lt;Run Text=\"&#123;Binding Name&#125;\" /&gt; &lt;Run Text=\"&#123;Binding Readout, StringFormat=&#123;&#125;&#123;0:f1&#125;&#125;\" /&gt; &lt;Run Text=\"&#123;Binding Unit, StringFormat=(&#123;0&#125;)&#125;\" /&gt; &lt;/TextBlock&gt; &lt;Slider Width=\"300\" VerticalAlignment=\"Center\" Maximum=\"&#123;Binding Maximum&#125;\" Minimum=\"&#123;Binding Minimum&#125;\" Orientation=\"Horizontal\" Value=\"&#123;Binding Readout&#125;\" /&gt; &lt;/StackPanel&gt; &lt;/ListBoxItem&gt; &lt;/ListBox&gt; &lt;/Grid&gt;&lt;/Window&gt; DataContext后台设置12345678910111213141516using System.Windows;namespace UdpJsonSender.WPF&#123; /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window &#123; public MainWindow() &#123; InitializeComponent(); DataContext = (Application.Current as App).IoC.Get&lt;AltPackViewModel&gt;(); &#125; &#125;&#125;","categories":[{"name":"C#/UDP","slug":"C-UDP","permalink":"https://loongegg.github.io/categories/C-UDP/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://loongegg.github.io/tags/C/"},{"name":"json","slug":"json","permalink":"https://loongegg.github.io/tags/json/"},{"name":"WPF","slug":"WPF","permalink":"https://loongegg.github.io/tags/WPF/"},{"name":"MVVM","slug":"MVVM","permalink":"https://loongegg.github.io/tags/MVVM/"}]},{"title":"C#/Udp-3.class类到json的序列化与反序列化","slug":"C-Udp-3-class类到json的序列化与反序列化","date":"2020-06-13T05:46:21.000Z","updated":"2020-06-13T12:11:03.864Z","comments":true,"path":"2020/06/13/C-Udp-3-class类到json的序列化与反序列化/","link":"","permalink":"https://loongegg.github.io/2020/06/13/C-Udp-3-class%E7%B1%BB%E5%88%B0json%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"摘要class类到json的序列化与反序列化前言1.系列主题本系列文章，旨在实现使用Json进行配置的Udp收发器 An Udp Sender &amp; Receiver using json file to configure 2.目标框架(target framework) .net framework 4.5 to support using in windows with .net framework &gt;= 4.5 .net standard 2.0 to support using in linux with .net core &gt;= 2.0 3.项目依赖（Dependency） LoongEgg.LoongLog an OpenSource cross-platform &amp; cross-framework log tool, you can get it from nuget or my github Newtonsoft.Json 4.项目地址(Source code) github 5.发行版获取 Search in nuget: LoongEgg.UdpCore 基本json文件1234567891011121314151617181920212223242526&#123; \"PackName\": \"AltitudePack\", \"PackID\": 233, \"Items\": [ &#123; \"Name\": \"GPS_Alt\", \"Unit\": \"m\", \"Length\": 2, \"BigEndian\": false, \"Resolution\": 1.0, \"Signed\": true, \"Maximum\": 100, \"Minimum\": -100 &#125;, &#123; \"Name\": \"BRAVO_Alt\", \"Unit\": \"m\", \"Length\": 2, \"BigEndian\": false, \"Resolution\": 0.5, \"Signed\": false, \"Maximum\": 100, \"Minimum\": -100 &#125; ]&#125; 单个数据项定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* | 个人微信：InnerGeeker | 联系邮箱：LoongEgg@163.com | 创建时间：2020/6/12 20:24:28 | 主要用途：数据包中单个数据项的定义 | 更改记录： | 时间 版本 更改 */namespace LoongEgg.UdpCore&#123; /// &lt;summary&gt; /// 单个数据项定义 /// &lt;/summary&gt; public class ItemConfig &#123; /// &lt;summary&gt; /// 数据名称 /// &lt;/summary&gt; public string Name &#123; get; set; &#125; /// &lt;summary&gt; /// 单位 /// &lt;/summary&gt; public string Unit &#123; get; set; &#125; /// &lt;summary&gt; /// 字节长度 /// &lt;/summary&gt; public int Length &#123; get; set; &#125; /// &lt;summary&gt; /// 大端在前？ /// &lt;/summary&gt; public bool BigEndian &#123; get; set; &#125; /// &lt;summary&gt; /// 数据精度，精度乘以传进来的数据=实际的数值 /// &lt;/summary&gt; public float Resolution &#123; get; set; &#125; /// &lt;summary&gt; /// 有无符号？ /// &lt;/summary&gt; public bool Signed &#123; get; set; &#125; /// &lt;summary&gt; /// 数据的最大值 /// &lt;/summary&gt; public float Maximum &#123; get; set; &#125; /// &lt;summary&gt; /// 数据的最小值 /// &lt;/summary&gt; public float Minimum &#123; get; set; &#125; /// &lt;summary&gt; /// 打印数据定义信息到字符串 /// &lt;/summary&gt; /// &lt;returns&gt;格式化后的定义信息&lt;/returns&gt; public override string ToString() &#123; return $\"Name=&#123;Name&#125;, Unit=&#123;Unit&#125;, Resolution=&#123;Resolution&#125;, Signed=\" + (Signed ? \"true\" : \"false\") + $\", Maximum=&#123;Maximum&#125;, Minimum=&#123;Minimum&#125;\"; &#125; &#125;&#125; 单个json文件对应的class定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596using Newtonsoft.Json;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;/* | 个人微信：InnerGeeker | 联系邮箱：LoongEgg@163.com | 创建时间：2020/6/12 20:41:39 | 主要用途：从json文件读取数据包协议 | 更改记录： | 时间 版本 更改 */namespace LoongEgg.UdpCore&#123; /// &lt;summary&gt; /// 数据包，可以直接从json文件反序列化 /// &lt;/summary&gt; public class JsonPackConfig &#123; /// &lt;summary&gt; /// 当前包的名字 /// &lt;/summary&gt; public string PackName &#123; get; set; &#125; = \"[Undefined]\"; /// &lt;summary&gt; /// 当前包的ID号, 注意为单字节无符号数 /// &lt;/summary&gt; public byte PackID &#123; get; set; &#125; /// &lt;summary&gt; /// 包的字节总长度, 注意最大长度为255 /// &lt;/summary&gt; public byte Length &#123; get &#123; int count = 0; if (Items.Any()) &#123; Items.ForEach(i =&gt; count += i.Length); return (byte)count; &#125; return 0; &#125; &#125; /// &lt;summary&gt; /// 数据对象定义的集合 /// &lt;/summary&gt; public List&lt;ItemConfig&gt; Items &#123; get; set; &#125; /// &lt;summary&gt; /// 从指定的文件反序列化数据包的定义 /// &lt;/summary&gt; /// &lt;param name=\"path\"&gt;文件路径&lt;/param&gt; /// &lt;returns&gt;反序列化后的数据包&lt;/returns&gt; public static JsonPackConfig DeserializeFromFile(string path) &#123; using (StreamReader reader = File.OpenText(path)) &#123; JsonSerializer serializer = JsonSerializer.Create(); var pack = serializer.Deserialize(reader, typeof(JsonPackConfig)) as JsonPackConfig; return pack; &#125; &#125; /// &lt;summary&gt; /// 将协议转换为json字符串形式 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string SerializeToJsonString() =&gt; JsonConvert.SerializeObject(this, Formatting.Indented); /// &lt;summary&gt; /// 将所有的数据协议项转换为一个字符串 /// &lt;/summary&gt; public override string ToString() &#123; StringBuilder builder = new StringBuilder(); builder.AppendLine($\"PackName=&#123;PackName&#125;, PackID=&#123;PackID&#125;:\"); if (Items.Any()) &#123; Items.ForEach( i =&gt; &#123; builder.AppendLine(i.ToString()); &#125;); return builder.ToString(); &#125; return \"JsonPackDefinition is undefined\"; &#125; &#125;&#125; 运用实例123456789101112131415161718192021222324252627using System;using System.Diagnostics;namespace LoongEgg.UdpCore.JsonDemo&#123; class Program &#123; static void Main(string[] args) &#123; try &#123; JsonPackConfig pack = JsonPackConfig.DeserializeFromFile(\"AltPack.json\"); Console.WriteLine(\"Desializing...\"); Console.WriteLine(pack.ToString()); Console.WriteLine(\"Serializing...\"); Console.WriteLine(pack.SerializeToJsonString()); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; Debugger.Break(); &#125; &#125;&#125;","categories":[{"name":"C#/UDP","slug":"C-UDP","permalink":"https://loongegg.github.io/categories/C-UDP/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://loongegg.github.io/tags/C/"},{"name":"UDP","slug":"UDP","permalink":"https://loongegg.github.io/tags/UDP/"},{"name":"json","slug":"json","permalink":"https://loongegg.github.io/tags/json/"}]},{"title":"C#/Udp-2.收发通信客户端的创建","slug":"C-Udp-2-收发通信客户端的创建","date":"2020-06-13T05:36:23.000Z","updated":"2020-06-13T11:29:48.229Z","comments":true,"path":"2020/06/13/C-Udp-2-收发通信客户端的创建/","link":"","permalink":"https://loongegg.github.io/2020/06/13/C-Udp-2-%E6%94%B6%E5%8F%91%E9%80%9A%E4%BF%A1%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"","text":"摘要基本UDP收发通信客户端的创建前言1.系列主题本系列文章，旨在实现使用Json进行配置的Udp收发器 An Udp Sender &amp; Receiver using json file to configure 2.目标框架(target framework) .net framework 4.5 to support using in windows with .net framework &gt;= 4.5 .net standard 2.0 to support using in linux with .net core &gt;= 2.0 3.项目依赖（Dependency） LoongEgg.LoongLog an OpenSource cross-platform &amp; cross-framework log tool, you can get it from nuget or my github Newtonsoft.Json 4.项目地址(Source code) github 5.发行版获取 Search in nuget: LoongEgg.UdpCore 发送端Program.cs1234567891011121314151617181920212223using LoongEgg.LoongLog;using System;namespace UdpSender.Net45&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(\"Hello World!\"); Logger.Enable(Loggers.ConsoleLogger | Loggers.DebugLogger); var sender = new LoongEgg.UdpCore.UdpSender(2233, true); bool stop = false; do &#123; Console.WriteLine(\"Enter a message or stop/s to exit\"); string input = Console.ReadLine(); stop = input.ToLower() == \"stop\" | input.ToLower() == \"s\"; sender.SendAsync($\"&#123;input&#125;\"); &#125; while (!stop); &#125; &#125;&#125; 接收端12345678910111213141516171819using LoongEgg.LoongLog;using System;namespace UdpReceiver.Net45&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(\"Hello World!\"); Logger.Enable(Loggers.ConsoleLogger | Loggers.DebugLogger); var receiver = new LoongEgg.UdpCore.UdpReceiver(2233); receiver.ReaderAsync().Wait(); Console.WriteLine(\"Good bye~\"); &#125; &#125;&#125;","categories":[{"name":"C#/UDP","slug":"C-UDP","permalink":"https://loongegg.github.io/categories/C-UDP/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://loongegg.github.io/tags/C/"},{"name":"UDP","slug":"UDP","permalink":"https://loongegg.github.io/tags/UDP/"}]},{"title":"C#/Udp-1.收发通信基础库的实现","slug":"C-Udp-1-收发通信基础库的实现","date":"2020-06-13T02:29:08.000Z","updated":"2020-06-16T12:11:58.258Z","comments":true,"path":"2020/06/13/C-Udp-1-收发通信基础库的实现/","link":"","permalink":"https://loongegg.github.io/2020/06/13/C-Udp-1-%E6%94%B6%E5%8F%91%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"摘要基本UDP收发通信基础库的实现前言1.系列主题本系列文章，旨在实现使用Json进行配置的Udp收发器 An Udp Sender &amp; Receiver using json file to configure 2.目标框架(target framework) .net framework 4.5 to support using in windows with .net framework &gt;= 4.5 .net standard 2.0 to support using in linux with .net core &gt;= 2.0 3.项目依赖（Dependency） LoongEgg.LoongLog an OpenSource cross-platform &amp; cross-framework log tool, you can get it from nuget or my github Newtonsoft.Json 4.项目地址(Source code) github 5.发行版获取 Search in nuget: LoongEgg.UdpCore UdpReceivedEventArgs.cs123456789101112131415161718192021222324/// &lt;summary&gt;/// Udp接收事件/// &lt;/summary&gt;public delegate void UdpReceivedEvent(object sender, UdpReceivedEventArgs args);/// &lt;summary&gt;/// Udp接收事件参数/// &lt;/summary&gt;public class UdpReceivedEventArgs: EventArgs&#123; /// &lt;summary&gt; /// 接收到的缓存信息 /// &lt;/summary&gt; public byte[] Buffer &#123; get; set; &#125; /// &lt;summary&gt; /// 默认构造器 /// &lt;/summary&gt; /// &lt;param name=\"buffer\"&gt;&lt;/param&gt; public UdpReceivedEventArgs(byte[] buffer) &#123; Buffer = buffer; &#125;&#125; UdpReceiver.cs1. Events1234/// &lt;summary&gt;/// 接收到新消息事件/// &lt;/summary&gt;public event UdpReceivedEvent MessageRecieved; 2. Fields1234567891011121314/// &lt;summary&gt;/// 默认配置文件/// &lt;/summary&gt;private static readonly string DefaultConfigFile = \"config.udpreceiver.json\";/// &lt;summary&gt;/// 使用说明/// &lt;/summary&gt;private static readonly string Usage = Environment.NewLine + \" Usage: -p port [-g groupaddress] [-t tag]\" + Environment.NewLine + \" -p port number listen to\" + Environment.NewLine + \" -g group address(224.0.0.0, 239.255.255.255)\" + Environment.NewLine + \" -t tag\" + Environment.NewLine + \" Info: config options will be saved as config.udpreceiver.json\"; 3. Properties1234567891011121314/// &lt;summary&gt;/// 端口号/// &lt;/summary&gt;public int Port &#123; get; set; &#125;/// &lt;summary&gt;/// 组地址/// &lt;/summary&gt;public string GroupAddress &#123; get; set; &#125;/// &lt;summary&gt;/// 接收器标识/// &lt;/summary&gt;public string Tag &#123; get; set; &#125; 4. Constructors123456789101112131415/// &lt;summary&gt;/// 默认构造函数/// &lt;/summary&gt;public UdpReceiver() &#123; &#125;/// &lt;summary&gt;/// 创建一个新的接收器/// &lt;/summary&gt;/// &lt;param name=\"port\"&gt;端口号&lt;/param&gt;/// &lt;param name=\"groupAddress\"&gt;组地址&lt;/param&gt;public UdpReceiver(int port, string groupAddress = null)&#123; GroupAddress = groupAddress; Port = port;&#125; 5. Public Methods123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/// &lt;summary&gt; /// 默认控制台程序实现 /// &lt;/summary&gt; /// &lt;param name=\"useDefaultConfig\"&gt;default=true, 使用默认的配置文件&lt;/param&gt; public static UdpReceiver DefaultConsole(bool useDefaultConfig = true) &#123; string hostName = Dns.GetHostName(); IPAddress[] IPs = Dns.GetHostAddresses(hostName); Logger.Info($\"HostName: &#123;hostName&#125;, Local IP(s):\"); if (IPs.Any()) &#123; IPs.ToList().ForEach(ip =&gt; &#123; if (ip.AddressFamily == AddressFamily.InterNetwork) Logger.Info($\" &#123;ip.ToString()&#125;\"); &#125;); &#125; Logger.Info($\"Try reading default UDP receiver config:&#123;DefaultConfigFile&#125;\"); UdpReceiver receiver = null; if (useDefaultConfig &amp;&amp; File.Exists(DefaultConfigFile)) &#123; using (StreamReader reader = File.OpenText(DefaultConfigFile)) &#123; JsonSerializer serializer = JsonSerializer.Create(); receiver = serializer.Deserialize(reader, typeof(UdpReceiver)) as UdpReceiver; if (receiver != null) &#123; Logger.Info(receiver.ToString()); Logger.Info(\"Reading default config OK.\"); &#125; &#125; &#125; else &#123; Logger.Warn(\"Reading default UDP receiver config falied!\"); Logger.Info(Usage); bool unconfig = true; do &#123; Logger.Info(\"Input udp config options:\"); string command = Console.ReadLine(); string[] args = command.Split(' '); int port; string group; string tag; ParseCommandOptions(args, out port, out group, out tag); if (port != 0) &#123; receiver = new UdpReceiver &#123; Port = port, GroupAddress = group, Tag = tag &#125;; Logger.Info(\"Udp initial as: \" + receiver.ToString() + \"?\"); Logger.Info($\"Enter Y/y to confirm, and save as [&#123;DefaultConfigFile&#125;]. OR any other keys to reinput.\"); unconfig = !(Console.ReadLine().ToLower() == \"y\"); &#125; else &#123; Logger.Warn(\"option missed: -p [port number] \"); &#125; &#125; while (unconfig); string json = JsonConvert.SerializeObject(receiver, Formatting.Indented); using (StreamWriter writer = File.CreateText(DefaultConfigFile)) &#123; writer.Write(json); writer.Flush(); writer.Close(); &#125; &#125; return receiver; &#125; /// &lt;summary&gt; /// 接收器工作 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task ReceiveAsync() &#123; using (var client = new UdpClient(Port)) &#123; if (GroupAddress != null) &#123; Logger.Debug($\"Join Multicast Group = &#123;GroupAddress&#125;\"); client.JoinMulticastGroup(IPAddress.Parse(GroupAddress)); &#125; Logger.Debug(\"Start Listening...Sending in [stop] to stop listening\"); bool completed; do &#123; UdpReceiveResult result = await client.ReceiveAsync(); byte[] datagram = result.Buffer; MessageRecieved?.Invoke(this, new UdpReceivedEventArgs(datagram)); string received = Encoding.UTF8.GetString(datagram); Logger.Info($\"Received (from &#123;result.RemoteEndPoint.Address&#125;) &lt; &#123;received&#125;\"); completed = (received.ToLower() == \"stop\"); &#125; while (!completed); if (GroupAddress != null) &#123; client.DropMulticastGroup(IPAddress.Parse(GroupAddress)); &#125; Logger.Warn(\"Listening stop command received.\"); Logger.Warn(\"Udp is stopping...\"); &#125; &#125; /// &lt;summary&gt; /// 显示Tag、Port、GroupAddress等详细信息 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override string ToString() &#123; return $\"&#123;nameof(Port)&#125;=&#123;Port&#125;, &#123;nameof(GroupAddress)&#125;=&#123;GroupAddress ?? \"null\"&#125;, &#123;nameof(Tag)&#125;=&#123;(Tag ?? \"null\")&#125;\"; &#125; 6. Private Methods12345678910111213/// &lt;summary&gt;/// 将数组转义到确切的UDP配置定义/// &lt;/summary&gt;/// &lt;param name=\"args\"&gt;命令参数&lt;/param&gt;/// &lt;param name=\"port\"&gt;端口号&lt;/param&gt;/// &lt;param name=\"group\"&gt;组地址&lt;/param&gt;/// &lt;param name=\"tag\"&gt;识别标签&lt;/param&gt;private static void ParseCommandOptions(string[] args, out int port, out string group, out string tag)&#123; UdpHelper.TryParseCommandParam(args, \"-p\", out port); UdpHelper.TryParseCommandParam(args, \"-g\", out group); UdpHelper.TryParseCommandParam(args, \"-t\", out tag);&#125; UdpSender.cs1.Fields12345678910/// &lt;summary&gt;/// IP端口/// &lt;/summary&gt;private IPEndPoint EndPoint;/// &lt;summary&gt;/// Udp端口/// &lt;/summary&gt;private UdpClient UdpClient;private const string DefaultConfigFile = \"config.udpsender.json\"; 2.Properties12345678910111213141516171819202122232425262728293031323334/// &lt;summary&gt;/// 端口号/// &lt;/summary&gt;public int Port &#123; get; set; &#125; = 5566;/// &lt;summary&gt;/// 组播/// &lt;/summary&gt;public bool IsBroadCast &#123; get; set; &#125;/// &lt;summary&gt;/// 组地址/// &lt;/summary&gt;public string GroupAddress &#123; get; set; &#125;/// &lt;summary&gt;/// 主机名字/// &lt;/summary&gt;public string HostName &#123; get; set; &#125;/// &lt;summary&gt;/// 小端在前？/// &lt;/summary&gt;public bool LittleEndian &#123; get; set; &#125;/// &lt;summary&gt;/// IpV6模式？/// &lt;/summary&gt;public bool IsIpV6 &#123; get; set; &#125;/// &lt;summary&gt;/// 标识/// &lt;/summary&gt;public string Tag &#123; get; set; &#125; 3.Constructors123456789101112131415161718192021222324/// &lt;summary&gt; /// Udp发送器的构造器, 创建后不要忘记调用&lt;see cref=\"Init()\"/&gt;进行初始化 /// &lt;/summary&gt; /// &lt;param name=\"port\"&gt;端口号&lt;/param&gt; /// &lt;param name=\"isBroadcast\"&gt;组播?&lt;/param&gt; /// &lt;param name=\"groupAddress\"&gt;组地址&lt;/param&gt; /// &lt;param name=\"isIpV6\"&gt;IpV6模式?&lt;/param&gt; [Obsolete(\"直接使用方法CreatFromConfig()更香，使用默认构造器，初始化时指定属性\")] public UdpSender( int port, bool isBroadcast = true, string groupAddress = null, bool isIpV6 = false) &#123; Port = port; IsBroadCast = isBroadcast; GroupAddress = groupAddress; IsIpV6 = IsIpV6; &#125; /// &lt;summary&gt; /// 默认构造器, 创建后不要忘记调用&lt;see cref=\"Init()\"/&gt;进行初始化 /// &lt;/summary&gt; public UdpSender() &#123; &#125; 3.Public Methods123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171 /// &lt;summary&gt; /// 从指定的配置文件创建一个发送器 /// &lt;/summary&gt; /// &lt;param name=\"path\"&gt;配置文件路径&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static UdpSender CreatFromConfig(string path = null) &#123; if (path == null) &#123; if (File.Exists(DefaultConfigFile)) &#123; using (StreamReader reader = File.OpenText(DefaultConfigFile)) &#123; JsonSerializer serializer = JsonSerializer.Create(); if (serializer.Deserialize(reader, typeof(UdpSender)) is UdpSender sender) &#123; Logger.Info($\"Reading default [&#123;DefaultConfigFile&#125;] config OK.\"); return sender; &#125; else &#123; string message = $\"UdpSender creat from default config file [&#123;DefaultConfigFile&#125;] failed\"; Logger.Warn(message); throw new ArgumentException(message); &#125; &#125; &#125; else &#123; Logger.Warn($\"Reading default config file [&#123;DefaultConfigFile&#125;] failed.\"); Logger.Warn(\"UdpSender creat with default property\"); return new UdpSender(); &#125; &#125; else &#123; using (StreamReader reader = File.OpenText(path)) &#123; JsonSerializer serializer = JsonSerializer.Create(); if (serializer.Deserialize(reader, typeof(UdpSender)) is UdpSender sender) &#123; Logger.Info(\"Reading default config OK.\"); return sender; &#125; else &#123; string message = $\"UdpSender creat from specifit config file [&#123;path&#125;] failed\"; Logger.Warn(message); throw new ArgumentException(message); &#125; &#125; &#125; &#125; /// &lt;summary&gt; /// 发送信息 /// &lt;/summary&gt; /// &lt;param name=\"message\"&gt;待发送的信息&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async void SendAsync(string message) &#123; if (EndPoint == null || UdpClient == null) throw new InvalidOperationException(\"Init() before first sending\"); try &#123; Logger.Info($\"Send &gt; &#123;message&#125;\"); byte[] datagram = Encoding.UTF8.GetBytes(message); await UdpClient.SendAsync(datagram, datagram.Length, EndPoint); &#125; catch (Exception ex) &#123; throw ex; &#125; &#125;/// &lt;summary&gt; /// 初始化端口 /// &lt;/summary&gt; public void Init() &#123; try &#123; EndPoint = GetIPEndPoint(Port, IsBroadCast, HostName, GroupAddress, IsIpV6).Result; UdpClient = new UdpClient &#123; EnableBroadcast = IsBroadCast &#125;; if (GroupAddress != null &amp;&amp; GroupAddress.ToLower() != \"null\") &#123; UdpClient.JoinMulticastGroup(IPAddress.Parse(GroupAddress)); &#125; Logger.Info(\"Udp sender initialized\"); Logger.Info(this.ToString() ); &#125; catch (Exception ex) &#123; throw ex; &#125; &#125; /// &lt;summary&gt; /// 将配置属性转为字符串 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override string ToString() =&gt; Environment.NewLine + $\"UdpSender: \" + Environment.NewLine + $\" &#123;nameof(Port)&#125;=&#123;Port&#125;\" + Environment.NewLine + $\" &#123;nameof(IsBroadCast)&#125;=&#123;IsBroadCast&#125;\" + Environment.NewLine + $\" &#123;nameof(HostName)&#125;=&#123;HostName&#125;\" + Environment.NewLine + $\" &#123;nameof(GroupAddress)&#125;=&#123;GroupAddress&#125;\" + Environment.NewLine + $\" &#123;nameof(IsIpV6)&#125;=&#123;IsIpV6&#125;\"; /*--------------------------------- Private Methods -------------------------------*/ /// &lt;summary&gt; /// 获取指定的IP端口 /// &lt;/summary&gt; /// &lt;param name=\"port\"&gt;端口号&lt;/param&gt; /// &lt;param name=\"isBroadcast\"&gt;组播?&lt;/param&gt; /// &lt;param name=\"hostName\"&gt;主机名称&lt;/param&gt; /// &lt;param name=\"groupAddress\"&gt;组地址&lt;/param&gt; /// &lt;param name=\"isIpV6\"&gt;IpV6模式?&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static async Task&lt;IPEndPoint&gt; GetIPEndPoint( int port, bool isBroadcast, string hostName, string groupAddress, bool isIpV6) &#123; IPEndPoint endpoint; try &#123; if (isBroadcast) &#123; endpoint = new IPEndPoint(IPAddress.Broadcast, port); Logger.Info($\"&#123;nameof(isBroadcast)&#125;=&#123;isBroadcast&#125;, &#123;nameof(port)&#125;=&#123;port&#125; \"); &#125; else if (hostName != null) &#123; IPHostEntry hostEntry = await Dns.GetHostEntryAsync(hostName); IPAddress address; if (isIpV6) &#123; address = hostEntry.AddressList.Where( a =&gt; a.AddressFamily == AddressFamily.InterNetworkV6 ).FirstOrDefault(); &#125; else &#123; address = hostEntry.AddressList.Where( a =&gt; a.AddressFamily == AddressFamily.InterNetwork ).FirstOrDefault(); &#125; endpoint = new IPEndPoint(address, port); Logger.Info($\"&#123;nameof(hostName)&#125;=&#123;hostName&#125;, &#123;nameof(address)&#125;=&#123;address&#125;, &#123;nameof(isIpV6)&#125;=&#123;isIpV6&#125;\"); &#125; else if (groupAddress != null) &#123; endpoint = new IPEndPoint(IPAddress.Parse(groupAddress), port); Logger.Info($\"&#123;nameof(groupAddress)&#125;=&#123;groupAddress&#125;, &#123;nameof(port)&#125;=&#123;port&#125; \"); &#125; else &#123; throw new InvalidOperationException($\"&#123;nameof(hostName)&#125;, &#123;nameof(isBroadcast)&#125;, or &#123;nameof(groupAddress)&#125; must be set\"); &#125; &#125; catch (Exception ex) &#123; throw ex; &#125; return endpoint; &#125; ~","categories":[{"name":"C#/UDP","slug":"C-UDP","permalink":"https://loongegg.github.io/categories/C-UDP/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://loongegg.github.io/tags/C/"},{"name":"UDP","slug":"UDP","permalink":"https://loongegg.github.io/tags/UDP/"},{"name":"Event","slug":"Event","permalink":"https://loongegg.github.io/tags/Event/"},{"name":"EventArgs","slug":"EventArgs","permalink":"https://loongegg.github.io/tags/EventArgs/"}]}],"categories":[{"name":"C#/UDP","slug":"C-UDP","permalink":"https://loongegg.github.io/categories/C-UDP/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://loongegg.github.io/tags/linux/"},{"name":"WSL","slug":"WSL","permalink":"https://loongegg.github.io/tags/WSL/"},{"name":"VS Code","slug":"VS-Code","permalink":"https://loongegg.github.io/tags/VS-Code/"},{"name":"C#","slug":"C","permalink":"https://loongegg.github.io/tags/C/"},{"name":".netcore","slug":"netcore","permalink":"https://loongegg.github.io/tags/netcore/"},{"name":"cross platform","slug":"cross-platform","permalink":"https://loongegg.github.io/tags/cross-platform/"},{"name":"json","slug":"json","permalink":"https://loongegg.github.io/tags/json/"},{"name":"MVVM","slug":"MVVM","permalink":"https://loongegg.github.io/tags/MVVM/"},{"name":"WPF","slug":"WPF","permalink":"https://loongegg.github.io/tags/WPF/"},{"name":"UDP","slug":"UDP","permalink":"https://loongegg.github.io/tags/UDP/"},{"name":"Event","slug":"Event","permalink":"https://loongegg.github.io/tags/Event/"},{"name":"EventArgs","slug":"EventArgs","permalink":"https://loongegg.github.io/tags/EventArgs/"}]}